<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DayZRP ADM Log Handler</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" />
  <link rel="stylesheet" href="css/map.css" />
  <link rel="stylesheet" href="logpullerstyle.css" />

  <style>
    :root { --bg:#0f1720; --panel:#0b1220; --muted:#9aa4b2; --accent:#7dd3fc; }

    html, body { 
      height: 100%; 
      margin: 0; 
      font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial; 
      font-size: 1.10rem; 
    }
    body { 
      background: linear-gradient(180deg, #050a15 0%, #0a1420 60%, var(--bg) 100%);
      background-attachment: fixed;
      background-repeat: no-repeat;
      background-size: cover;
      color: #e6eef6; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      padding: 32px; 
    }

    .wrap { width: min(1800px, 96%); max-width: 1800px; }

    header { display: flex; align-items: center; justify-content: space-between; gap: 18px; margin-bottom: 24px; flex-wrap: wrap; }
    h1 { margin: 0; font-size: 1.45rem; }

    .controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .btn { background: transparent; border: 1px solid rgba(255,255,255,0.06); padding: 13px 15px; border-radius: 10px; cursor: pointer; color: inherit; font-size: 1.02rem; transition: all .2s ease; }
    .btn:hover { background: rgba(255,255,255,0.05); border-color: var(--accent); }

    select, .textlike{
      background: rgba(255,255,255,0.92); border: 1px solid rgba(255,255,255,0.92);
      border-radius: 10px; color:#0b1220; padding:11px 13px; font-size:1.02rem; cursor:pointer; transition:border .2s ease;
    }
    select:hover, select:focus{outline:none;border-color:#bfeaff;box-shadow:0 0 0 2px rgba(125,211,252,.25)}
    input[type=file]{display:none}

    .filters { display: flex; justify-content: center; align-items: center; gap: 26px; margin-bottom: 20px; }
    .filters label { display: flex; align-items: center; gap: 10px; font-size: 1.05rem; color: var(--muted); cursor: pointer; }
    .filters input[type="checkbox"] { transform: scale(1.35); accent-color: var(--accent); cursor: pointer; }

    .panel{
      background:var(--panel); padding:22px; border-radius:12px; border:1px solid rgba(255,255,255,0.08);
      display:flex; gap:22px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;
    }
    
    #playerListContainer{flex:0 0 340px;display:flex;flex-direction:column;gap:12px;max-height:880px;min-width:300px;}
    #playerSearch{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:#e6eef6;padding:11px 13px;font-size:1.02rem;outline:none;width:100%;box-sizing:border-box;}

    #playerSearch:focus{border-color:var(--accent);}
    .searchButtons{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:6px;}
    .small-btn{ padding:11px 13px; flex:0 0 auto; }

    #playerList{ overflow-y:auto; overflow-x:hidden; display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:10px 18px; flex:1; padding-top:4px; }
    .player-entry{ display:flex; align-items:center; gap:9px; cursor:pointer; font-size:1.02rem; color:var(--muted); padding:7px 9px; border-radius:8px; line-height:1.2; min-width:0; transition:all .2s ease; white-space:nowrap; }
    .player-entry:hover{background:rgba(255,255,255,0.05); color:var(--accent);}
    .player-entry input[type="checkbox"]{ accent-color:var(--accent); cursor:pointer; transform:scale(1.25); flex:0 0 auto; }
    .player-entry span{ display:block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; min-width:0; }
    .color-swatch{ appearance:none; -webkit-appearance:none; width:17px; height:17px; flex:0 0 17px; border:2px solid rgba(255,255,255,0.25); border-radius:4px; padding:0; margin:0; cursor:pointer; background:transparent; box-sizing:content-box; display:block; }
    .color-swatch::-webkit-color-swatch-wrapper{padding:0;}
    .color-swatch::-webkit-color-swatch{border:none;}

    #map{ flex:1; aspect-ratio:1 / 1; border-radius:12px; overflow:hidden; background:#121212; max-width:980px; min-width:820px; min-height:780px; margin:0 auto; }

    #logPuller { flex:0 0 340px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.08);
      border-radius:12px; padding:14px; display:flex; flex-direction:column; gap:14px; }
    #logPuller h2 { margin:0 0 6px; font-size:1.15rem; }
    .lp-section { background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.08); border-radius:10px; padding:12px; display:flex; flex-direction:column; gap:10px; }
    .lp-row { display:flex; gap:8px; align-items:center; }
    .lp-label { color:var(--muted); font-weight:600; font-size:1rem; }
    .lp-checks { display:flex; flex-direction:column; gap:10px; }
    .lp-checks label { display:flex; gap:10px; align-items:center; color:var(--muted); cursor:pointer; }
    .lp-checks input[type="checkbox"] { transform:scale(1.15); accent-color: var(--accent); }
    .btn.place { padding:11px 13px; }
    .btn.pull { padding:14px 16px; font-weight:700; }

    .marker-tip.leaflet-tooltip{
      background: rgba(5,10,18,0.92);
      color: #e6eef6;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.45);
      font-size: 1rem;
    }
    
    .marker-tip .leaflet-tooltip-tip{
      background: rgba(5,10,18,0.92);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .tip-ord { color: var(--accent); font-weight: 700; margin-bottom: 2px; }
    .tip-name { font-weight: 600; }
    .tip-time { color: var(--muted); font-size: 0.95rem; }
    .tip-coord{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.95rem; }

    .focus-pin{width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:12px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.6);border:2px solid var(--accent);box-shadow:0 0 10px rgba(0,0,0,.6);}
    .focus-v{background:#e53935;border-color:#e57373;}
    .focus-a{background:#1e88e5;border-color:#64b5f6;}



    footer{margin-top:20px; color:var(--muted); font-size:1rem; text-align:center;}

    .logs-wrap{width:100%;}
    .logs-title{
      width:100%;
      text-align:center;
      font-family:inherit;
      font-size:1.25rem;
      font-weight:700;
      letter-spacing:.02em;
      color:#cfd8e3;
      margin:0 0 14px;
      text-transform:none;
    }
    .accordion{
      width:100%;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:stretch;
      margin:0;
    }
    .acc-item{
      width:100%;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:10px;
      overflow:hidden;
      text-align:left;
    }
    .acc-head{
      width:100%;
      text-align:left;
      background:var(--panel);
      color:#e6eef6;
      padding:14px 16px;
      border:none;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.02em;
    }
    .acc-head:hover{ background:#0d1320; }
    .acc-body{ display:none; padding:14px 16px; color:#d7e0ea; border-top:1px solid rgba(255,255,255,0.06); }
    .acc-item.open .acc-body{ display:block; }
    .acc-item.open .acc-head{ background:#0a1320; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; white-space: pre-wrap; line-height: 1.35; }
    .hl-pos { color:#facc15; font-weight:700; }

    @media (max-width: 1500px) {
      #map { min-width: 100%; max-width: 100%; min-height: 700px; }
      #logPuller { flex: 1 1 100%; order: 3; }
      .logs-wrap{ width: 100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>DayZRP ADM Log Handler</h1>
      <div class="controls">
        <label class="btn" for="admLogInput">üìÅ Upload ADM Log</label>
        <input id="admLogInput" type="file" accept=".adm,.txt,.log" />
        <button class="btn" id="fitBtn">Fit</button>
        <select id="startTime"><option>Start Time</option></select>
        <select id="endTime"><option>End Time</option></select>
      </div>
    </header>

    <div class="filters">
      <label><input type="checkbox" id="chkMarkers" checked>Markers</label>
      <label><input type="checkbox" id="chkPaths" checked>Paths</label>
      <label><input type="checkbox" id="chkHits" checked>Hits</label>
      <label><input type="checkbox" id="chkKills" checked>Kills</label>
    </div>

    <div class="panel">
      <div id="playerListContainer">
        <div class="searchBlock">
          <input type="text" id="playerSearch" placeholder="Search player..." />
          <div class="searchButtons">
            <button class="btn small-btn" id="btnSelectAll">Select All</button>
            <button class="btn small-btn" id="btnClearSel">Clear</button>
            <label style="display:flex;align-items:center;gap:8px;margin-left:6px;">
              <input type="checkbox" id="chkOnlySelected" style="transform:scale(1.2);accent-color:var(--accent);cursor:pointer;">
              <span style="color:var(--muted);">Only Show Selected</span>
            </label>
          </div>
        </div>
        <div id="playerList"></div>
      </div>

      <div id="map"></div>

      <aside id="logPuller" aria-label="Log Puller">
        <h2>Log Puller</h2>

        <section class="lp-section" aria-label="Radius Select">
          <div class="lp-label">Radius Select</div>
          <div class="lp-row">
            <select id="radiusSelect" title="Radius">
              <option value="50">50</option>
              <option value="100">100</option>
              <option value="150">150</option>
              <option value="200">200</option>
              <option value="250">250</option>
              <option value="500">500</option>
              <option value="1000">1000</option>
              <option value="1500">1500</option>
            </select>
            <button class="btn place" id="btnPlace">Place</button>
          </div>
        </section>

        <section class="lp-section" aria-label="Logs To Pull">
          <div class="lp-label">Logs To Pull</div>
          <div class="lp-checks">
            <label><input type="checkbox" id="chkConnLogs">Connection Logs</label>
            <label><input type="checkbox" id="chkPosLogs">Position Logs</label>
            <label><input type="checkbox" id="chkChatLogs">Chat Logs</label>
            <label><input type="checkbox" id="chkHitLogs">Hit Logs</label>
            <label><input type="checkbox" id="chkKillLogs">Kill Logs</label>
          </div>
        </section>

        <section class="lp-section" aria-label="Extra Timeframe">
          <div class="lp-label">Extra Timeframe</div>
          <select id="timeframeSelect" title="Extra Timeframe">
            <option value="15m">15 Minutes</option>
            <option value="30m">30 Minutes</option>
            <option value="1h">1 Hour</option>
            <option value="2h">2 Hours</option>
          </select>
        </section>

        <button class="btn pull" id="btnPull">Pull!</button>
      </aside>
    </div>

    <div class="logs-wrap">
      <h2 class="logs-title">LOGS</h2>
      <div class="accordion" id="logsAccordion">
        <div class="acc-item" data-log="conn">
          <button class="acc-head">CONNECTION LOGS</button>
          <div class="acc-body" id="logs-conn"><em>No data yet.</em></div>
        </div>
        <div class="acc-item" data-log="pos">
          <button class="acc-head">POSITION LOGS</button>
          <div class="acc-body" id="logs-pos"><em>No data yet.</em></div>
        </div>
        <div class="acc-item" data-log="chat">
          <button class="acc-head">CHAT LOGS</button>
          <div class="acc-body" id="logs-chat"><em>No data yet.</em></div>
        </div>
        <div class="acc-item" data-log="hit">
          <button class="acc-head">HIT LOGS</button>
          <div class="acc-body" id="logs-hit"><em>No data yet.</em></div>
        </div>
        <div class="acc-item" data-log="kill">
          <button class="acc-head">KILL LOGS</button>
          <div class="acc-body" id="logs-kill"><em>No data yet.</em></div>
        </div>
      </div>
    </div>

    <footer>DayZRP ‚Ä¢ @Cole ‚Ä¢ Hofer Stinky</footer>
  </div>

  <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"></script>
  <script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="js/mapUtils.js"></script>
  <script src="js/defaultMap.js"></script>
  <script src="maps/enoch.js"></script>

  <script>
    let map;
    let admEntries = [];
    let damageEvents = [];
    let killEvents = [];
    let filteredPlayers = [];
    const playerColors = {};
    const selectedPlayers = new Set();
    const connectionLines = [];
    let placingRadius = false;
    let currentRadiusCircle = null; 
    let currentRadiusMeters = null; 
    let currentRadiusCenter = null; 

    const panes = {
      paths:'pathsPane',
      arrows:'arrowsPane',
      markers:'markersPane',
      damage:'damagePane',
      kills:'killsPane',
      focus:'focusPane',
      radius:'radiusPane'
    };
    const layers = {
      markers:L.layerGroup(),
      paths:L.layerGroup(),
      arrows:L.layerGroup(),
      hits:L.layerGroup(),
      kills:L.layerGroup(),
      focus:L.layerGroup(),
      radius:L.layerGroup()
    };
    let inDamageFocus = false;

    function initMap() {
      const EXTRA_ZOOM = 5;
      const maxNative  = Arma3Map.Maps.enoch.maxZoom || 7;
      const allowMax   = maxNative + EXTRA_ZOOM;
      const world      = Arma3Map.Maps.enoch.worldSize;
      const worldBounds = L.latLngBounds([[0, 0], [world, world]]);

      map = L.map('map', { minZoom: Arma3Map.Maps.enoch.minZoom, maxZoom: allowMax, crs: Arma3Map.Maps.enoch.CRS, zoomControl: true, zoomSnap: 0.25, zoomDelta: 0.5 });
      L.tileLayer(Arma3Map.Maps.enoch.tilePattern, { tileSize: Arma3Map.Maps.enoch.tileSize, minZoom: Arma3Map.Maps.enoch.minZoom, maxZoom: allowMax, maxNativeZoom: maxNative, keepBuffer: 4, updateWhenZooming: true, updateInterval: 50, noWrap: true, bounds: worldBounds }).addTo(map);

      map.createPane(panes.paths);   map.getPane(panes.paths).style.zIndex   = 450;
      map.createPane(panes.arrows);  map.getPane(panes.arrows).style.zIndex  = 460;
      map.createPane(panes.markers); map.getPane(panes.markers).style.zIndex = 470;
      map.createPane(panes.damage);  map.getPane(panes.damage).style.zIndex  = 480;
      map.createPane(panes.kills);   map.getPane(panes.kills).style.zIndex   = 485;
      map.createPane(panes.focus);   map.getPane(panes.focus).style.zIndex   = 490;
      map.createPane(panes.radius);  map.getPane(panes.radius).style.zIndex  = 465;

      $.each(Arma3Map.Maps.enoch.cities, function(_, city){
        const labelIcon = L.divIcon({ iconSize: null, className: "map-label", html: "<span>" + city.name + "</span>" });
        L.marker([city.y, city.x], { icon: labelIcon, clickable: false, title: city.name }).addTo(map);
      });

      layers.paths.addTo(map); layers.arrows.addTo(map); layers.markers.addTo(map);
      layers.hits.addTo(map); layers.kills.addTo(map); layers.focus.addTo(map); layers.radius.addTo(map);

      map.on('zoomend', refreshMapLayers);

      map.on('click', (e) => {
        if (!placingRadius) return;
        placingRadius = false;
        map.getContainer().style.cursor = '';
        const r = parseInt(document.getElementById('radiusSelect').value, 10) || 100;
        placeRadiusCircle(e.latlng, r);
        applyRadiusSelection();
        refreshMapLayers();
      });

      fitMap();
    }
    
    function handleADMUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => parseADMLog(reader.result);
      reader.readAsText(file);
    }

    function fitMap() {
      const world = Arma3Map.Maps.enoch.worldSize;
      const bounds = L.latLngBounds([[0, 0], [world, world]]);
      map.setMaxBounds(bounds);
      const z = map.getBoundsZoom(bounds, true);
      map.setView(bounds.getCenter(), z, { animate: false });
    }

    document.addEventListener('DOMContentLoaded', () => {
      initMap();

      document.getElementById('fitBtn').addEventListener('click', fitMap);
      document.getElementById('playerSearch').addEventListener('input', filterPlayerList);
      document.getElementById('admLogInput').addEventListener('change', handleADMUpload);

      document.getElementById('startTime').addEventListener('change', () => {
        updateEndTimeOptions();
        if (currentRadiusCircle) applyRadiusSelection();
        refreshMapLayers();
      });
      document.getElementById('endTime').addEventListener('change', () => {
        updatePlayerList();
        if (currentRadiusCircle) applyRadiusSelection();
        refreshMapLayers();
      });

      document.getElementById('btnSelectAll').addEventListener('click', () => setAllVisibleChecks(true));
      document.getElementById('btnClearSel').addEventListener('click', () => {
        setAllVisibleChecks(false);
        if (currentRadiusCircle) {
          layers.radius.clearLayers();
          currentRadiusCircle = null;
          currentRadiusCenter = null;
          currentRadiusMeters = null;
        }
      });

      document.getElementById('chkOnlySelected').addEventListener('change', () => {
        filterPlayerList();
      });

      ['chkMarkers','chkPaths','chkHits','chkKills'].forEach(id => {
        document.getElementById(id).addEventListener('change', refreshMapLayers);
      });
      
      document.getElementById('btnPlace').addEventListener('click', () => {
        placingRadius = true;
        map.getContainer().style.cursor = 'crosshair';
      });

      document.querySelectorAll('.acc-head').forEach(btn => {
        btn.addEventListener('click', () => {
          const item = btn.parentElement;
          item.classList.toggle('open');
        });
      });

      // LogPull
      document.getElementById('btnPull').addEventListener('click', () => {
        // Connections
        if (document.getElementById('chkConnLogs').checked) {
          renderConnectionLogs();
        } else {
          document.getElementById('logs-conn').innerHTML = '<em>No data requested.</em>';
        }
      
        // Positions
        if (document.getElementById('chkPosLogs').checked) {
          renderPositionLogs();
        } else {
          document.getElementById('logs-pos').innerHTML = '<em>No data requested.</em>';
        }

        // Hits
        if (document.getElementById('chkHitLogs').checked) {
          renderHitLogs();
        } else {
          document.getElementById('logs-hit').innerHTML = '<em>No data requested.</em>';
        }
        
        // Kills
        if (document.getElementById('chkKillLogs').checked) {
          renderKillLogs();
        } else {
          document.getElementById('logs-kill').innerHTML = '<em>No data requested.</em>';
        }
     
        // Chat
        if (document.getElementById('chkChatLogs').checked) {
          renderChatLogs();
        } else {
          document.getElementById('logs-chat').innerHTML = '<em>No data requested.</em>';
        }
      });
   });
    
    // Parsing
    const POS_LINE_RE   = /^(\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"([^"]+)"(?:\s*\(DEAD\))?\s*\(id=(\d{17})\s+pos=<\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*(-?[\d.]+)\s*>\)\s*(?:\[\s*HP:\s*([^\]]+)\s*\])?\s*$/;
    const HIT_PVP_RE = /^(\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"([^"]+)"(?:\s*\(DEAD\))?\s*\(id=(\d{17})\s+pos=<\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*(-?[\d.]+)\s*>\)\s*\[HP:\s*([^\]]+)\]\s*hit by Player\s+"([^"]+)"\s*(?:\(DEAD\))?\s*\(id=(\d{17})\s+pos=<\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*(-?[\d.]+)\s*>\)\s*into\s*([^(]+)\(\d+\)\s*for\s*([\d.]+)\s*damage\s*\(([^)]+)\)\s*with\s*([^]+?)(?:\s*from\s*([\d.]+)\s*meters\s*)?$/;
    const HIT_OTHER_RE  = /^(\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"([^"]+)"(?:\s*\(DEAD\))?\s*\(id=(\d{17})\s+pos=<\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*(-?[\d.]+)\s*>\)\s*\[HP:\s*([^\]]+)\]\s*hit by\s*([^]+?)\s*(?:into\s*([^(]+)\(\-?\d+\)\s*)?(?:for\s*([\d.]+)\s*damage\s*)?(?:\(([^)]+)\)\s*)?(?:with\s*([^]+?))?(?:\s*from\s*([\d.]+)\s*meters\s*)?$/;
    const KILL_PVP_RE   = /^(\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"([^"]+)"\s*\(DEAD\)\s*\(id=(\d{17})\s+pos=<\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*(-?[\d.]+)\s*>\)\s*killed by\s*Player\s+"([^"]+)"\s*\(id=(\d{17})\s+pos=<\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*(-?[\d.]+)\s*>\)\s*with\s*([^]+?)\s*$/;
    const HIT_PVP_MELEE_RE =/^(\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"([^"]+)"(?:\s*\(DEAD\))?\s*\(id=(\d{17})\s+pos=<\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*(-?[\d.]+)\s*>\)\s*\[HP:\s*([^\]]+)\]\s*hit by Player\s+"([^"]+)"\s*\(id=(\d{17})\s+pos=<\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*(-?[\d.]+)\s*>\)\s*into\s*([^(]+)\(\d+\)\s*for\s*([\d.]+)\s*damage\s*\(([^)]+)\)\s*$/;
    const CHAT_RE = /^(\d{2}:\d{2}:\d{2})\s*\|\s*\[Chat\s*-\s*[^\]]+\]\("([^"]+)"\(id=[^)]+\)\):\s*(.*)$/;
    const CONNECT_RE    = /^(\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"([^"]+)"\(id=[^)]+\)\s*is connected\s*$/;
    const DISCONNECT_RE = /^(\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"([^"]+)"\(id=[^)]+\)\s*has been disconnected\s*$/;

    function parseADMLog(text) {
      admEntries = [];
      damageEvents = [];
      killEvents = [];
      connectionLines.length = 0;
    
      window._rawLines = text.split('\n').map(l => l.replace(/\r$/, ''));
    
      window._rawLines.forEach(line => {
    
        const p = line.match(POS_LINE_RE);
        if (p) {
          admEntries.push({
            time: p[1], name: p[2], steamId: p[3],
            x: +p[4], y: +p[5], z: +p[6], hp: p[7] ?? null
          });
          return;
        }
    
        let m = line.match(CONNECT_RE);
        if (m) { connectionLines.push({ time: m[1], name: m[2], type: 'connect' }); return; }
        m = line.match(DISCONNECT_RE);
        if (m) { connectionLines.push({ time: m[1], name: m[2], type: 'disconnect' }); return; }
    
        // Hits PVP
        const hP = line.match(HIT_PVP_RE);
        if (hP) {
          damageEvents.push({
            kind: 'pvp',
            time: hP[1],
            victim:  { name: hP[2], id: hP[3], x:+hP[4], y:+hP[5], z:+hP[6], hp:hP[7] },
            attacker:{ name: hP[8], id: hP[9], x:+hP[10], y:+hP[11], z:+hP[12] },
            bodypart: hP[13].trim(),
            damage: +hP[14],
            ammo:   hP[15].trim(),
            weapon: hP[16].trim(),
            meters: +(hP[17] || 0)
          });
          return;
        }
    
        // Melee Damage
        const hPM = line.match(HIT_PVP_MELEE_RE);
        if (hPM) {
          damageEvents.push({
            kind: 'pvp',
            time: hPM[1],
            victim:  { name: hPM[2], id: hPM[3], x:+hPM[4], y:+hPM[5], z:+hPM[6], hp:hPM[7] },
            attacker:{ name: hPM[8], id: hPM[9], x:+hPM[10], y:+hPM[11], z:+hPM[12] },
            bodypart: hPM[13].trim(),
            damage: +hPM[14],
            ammo:   hPM[15].trim(),
            weapon: 'Melee',
            meters: null
          });
          return;
        }
    
        // Other Damage
        const hO = line.match(HIT_OTHER_RE);
        if (hO) {
          damageEvents.push({
            kind:'other',
            time: hO[1],
            victim:{ name:hO[2], id:hO[3], x:+hO[4], y:+hO[5], z:+hO[6], hp:hO[7] },
            by:    hO[8]?.trim() || 'Unknown',
            bodypart: (hO[9]?.trim() || ''),
            damage:   hO[10] ? +hO[10] : null,
            ammo:     hO[11]?.trim() || '',
            weapon:   hO[12]?.trim() || '',
            meters:   hO[13] ? +hO[13] : null
          });
          return;
        }
    
        // Kills
        const k = line.match(KILL_PVP_RE);
        if (k) {
          killEvents.push({
            time: k[1],
            victim:  { name:k[2], id:k[3], x:+k[4], y:+k[5], z:+k[6] },
            attacker:{ name:k[7], id:k[8], x:+k[9], y:+k[10], z:+k[11] },
            weapon: k[12].trim()
          });
          return;
        }
      });
    
      updateTimeSelectors(true);
      updatePlayerList();
      if (currentRadiusCircle) applyRadiusSelection(); 
      refreshMapLayers();
    }

    const uniqueSortedPosTimes = () => [...new Set(admEntries.map(e => e.time))].sort();

    function updateTimeSelectors(defaultBothFirst = false) {
      const startSel = document.getElementById('startTime');
      const endSel = document.getElementById('endTime');
      startSel.innerHTML = '';
      endSel.innerHTML = '';
      const times = uniqueSortedPosTimes();
      for (const t of times) { startSel.add(new Option(t, t)); }

      if (times.length) {
        startSel.value = times[0];
        updateEndTimeOptions();
        if (defaultBothFirst) { endSel.value = times[0]; }
      }
    }

    function updateEndTimeOptions() {
      const startSel = document.getElementById('startTime');
      const endSel = document.getElementById('endTime');
      const selectedStart = startSel.value;
      const times = uniqueSortedPosTimes();
      endSel.innerHTML = '';
      for (const t of times) if (t >= selectedStart) endSel.add(new Option(t, t));
      if (endSel.options.length && (endSel.value < selectedStart)) endSel.value = selectedStart;
      updatePlayerList();
    }

    function updatePlayerList() {
      const start = document.getElementById('startTime').value;
      const end   = document.getElementById('endTime').value;

      const names = new Set(
        admEntries.filter(e => e.time >= start && e.time <= end).map(e => e.name)
      );
      damageEvents.forEach(d => { if (d.time >= start && d.time <= end) names.add(d.victim.name); });
      killEvents.forEach(k => { if (k.time >= start && k.time <= end) { names.add(k.victim.name); names.add(k.attacker.name); } });

      const list = [...names].sort();
      list.forEach(n => { if (!playerColors[n]) playerColors[n] = '#ff4d4d'; });
      filteredPlayers = list;
      renderPlayerList(filteredPlayers);
    }

    function filterPlayerList() {
      const q = document.getElementById('playerSearch').value.toLowerCase();
      const onlySel = document.getElementById('chkOnlySelected').checked;

      let base = filteredPlayers;
      if (onlySel) base = base.filter(n => selectedPlayers.has(n));
      const names = base.filter(n => n.toLowerCase().includes(q));

      renderPlayerList(names);
    }

    function renderPlayerList(names) {
      const list = document.getElementById('playerList');
      list.innerHTML = '';
      names.forEach(n => {
        const row = document.createElement('div');
        row.className = 'player-entry';
        row.title = n;

        const color = document.createElement('input');
        color.type = 'color';
        color.className = 'color-swatch';
        color.value = playerColors[n] || '#ff4d4d';
        color.addEventListener('input', () => { playerColors[n] = color.value; refreshMapLayers(); });

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.value = n;
        cb.checked = selectedPlayers.has(n);
        cb.addEventListener('change', () => {
          if (cb.checked) selectedPlayers.add(n);
          else selectedPlayers.delete(n);
          if (document.getElementById('chkOnlySelected').checked) filterPlayerList();
          refreshMapLayers();
        });

        const span = document.createElement('span');
        span.textContent = n;

        row.appendChild(color);
        row.appendChild(cb);
        row.appendChild(span);
        list.appendChild(row);
      });
    }

    function setAllVisibleChecks(checked) {
      document.querySelectorAll('#playerList .player-entry input[type="checkbox"]').forEach(cb => {
        cb.checked = checked;
        if (checked) selectedPlayers.add(cb.value);
        else selectedPlayers.delete(cb.value);
      });
      refreshMapLayers();
      if (document.getElementById('chkOnlySelected').checked) filterPlayerList();
    }

    function getSelectedPlayers() {
      return Array.from(selectedPlayers);
    }

    const segmentMidpoint = (a, b) => L.latLng((a.lat + b.lat) / 2, (a.lng + b.lng) / 2);

    function sizesForZoom(z) {
      const markerRadius = Math.max(1.9, 6.4 - 0.95 * z);
      const pathWeight   = Math.max(0.9, 3.8 - 0.52 * z);
      const arrowSize    = Math.max(10, 19 - 1.55 * z);
      const starSize     = Math.max(13, 21 - 1.05 * z);
      const skullSize    = Math.max(15, 23 - 1.15 * z);
      return { markerRadius, pathWeight, arrowSize, starSize, skullSize };
    }

    function coordsHTML(x,y,z){ return `&lt;${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)}&gt;`; }
    function timeToSec(t){ const [h,m,s]=t.split(':').map(Number); return h*3600+m*60+s; }
    function secToTime(sec){ const s=((sec%86400)+86400)%86400; const h=String(Math.floor(s/3600)).padStart(2,'0'); const m=String(Math.floor((s%3600)/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${h}:${m}:${ss}`; }
    function stripIds(line){
      return line.replace(/\(id=[^)]+\)/g, '').replace(/\s{2,}/g, ' ');
    }
    function lineTime(line){
      const m = line.match(/^(\d{2}:\d{2}:\d{2})\s*\|/);
      return m ? m[1] : null;
    }
    function extraWindowSecs(){
      const v = document.getElementById('timeframeSelect').value;
      if (v.endsWith('m')) return parseInt(v)*60;
      if (v.endsWith('h')) return parseInt(v)*3600;
      return 0;
    }

    // Radius Select
    function placeRadiusCircle(latlng, radiusMeters){
      layers.radius.clearLayers();
      currentRadiusCircle = null;

      const circle = L.circle(latlng, {
        pane: panes.radius,
        radius: radiusMeters,
        color: '#7dd3fc',
        weight: 1.5,
        fill: true,
        fillOpacity: 0.15,
        opacity: 0.9,
        dashArray: '5,4'
      }).addTo(layers.radius);

      currentRadiusCircle = circle;
      currentRadiusMeters = radiusMeters;
      currentRadiusCenter = { x: latlng.lng, y: latlng.lat };
    }

    function distXY(a, b){
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function applyRadiusSelection(){
      if (!currentRadiusCircle || !currentRadiusCenter) return;

      const start = document.getElementById('startTime').value;
      const end   = document.getElementById('endTime').value;
      const R     = currentRadiusMeters;

      const inside = new Set();

      // Positions
      admEntries.forEach(e => {
        if (e.time < start || e.time > end) return;
        const pt = { x: e.x, y: e.y };
        if (distXY(pt, currentRadiusCenter) <= R) inside.add(e.name);
      });

      // Damage
      damageEvents.forEach(d => {
        if (d.time < start || d.time > end) return;
        const pt = { x: d.victim.x, y: d.victim.y };
        if (distXY(pt, currentRadiusCenter) <= R) inside.add(d.victim.name);
      });

      // Kills
      killEvents.forEach(k => {
        if (k.time < start || k.time > end) return;
        const pt = { x: k.victim.x, y: k.victim.y };
        if (distXY(pt, currentRadiusCenter) <= R) {
          inside.add(k.victim.name);
          inside.add(k.attacker.name);
        }
      });

      selectedPlayers.clear();
      inside.forEach(n => selectedPlayers.add(n));
      filterPlayerList();
    }

    // Rendering
    function refreshMapLayers() {
      if (inDamageFocus) return;

      layers.markers.clearLayers();
      layers.paths.clearLayers();
      layers.arrows.clearLayers();
      layers.hits.clearLayers();
      layers.kills.clearLayers();
      layers.focus.clearLayers();

      const showMarkers = document.getElementById('chkMarkers').checked;
      const showPaths   = document.getElementById('chkPaths').checked;
      const showHits    = document.getElementById('chkHits').checked;
      const showKills   = document.getElementById('chkKills').checked;

      const start = document.getElementById('startTime').value;
      const end   = document.getElementById('endTime').value;
      const selected = new Set(getSelectedPlayers());
      if (!selected.size) return;

      const { markerRadius, pathWeight, arrowSize, starSize, skullSize } = sizesForZoom(map.getZoom());

      // Paths + Markers Handler
      const bucket = {};
      admEntries.forEach(e => {
        if (e.time < start || e.time > end) return;
        if (!selected.has(e.name)) return;
        (bucket[e.name] ??= []).push(e);
      });
      Object.values(bucket).forEach(arr => arr.sort((a,b) => a.time.localeCompare(b.time)));

      Object.keys(bucket).forEach(name => {
        const entries = bucket[name];
        const N = entries.length;
        const color = playerColors[name] || '#ff4d4d';

        if (showMarkers) {
          entries.forEach((e, idx) => {
            const latlng = L.latLng(e.y, e.x);
            const m = L.circleMarker(latlng, {
              pane: panes.markers, radius: markerRadius,
              color, weight: Math.max(1, pathWeight - 0.4), opacity: 1, fillOpacity: 0.6
            }).addTo(layers.markers);

            const tipHTML = `
              <div class="tip-ord">${idx+1}/${N}</div>
              <div class="tip-name">${name}</div>
              <div class="tip-time">${e.time}</div>
              <div class="tip-coord">${coordsHTML(e.x,e.y,e.z)}</div>
            `;
            m.bindTooltip(tipHTML, { direction:'top', sticky:true, opacity:1, className:'marker-tip', offset:L.point(0,-8) });
          });
        }

        const pts = entries.map(e => L.latLng(e.y, e.x));
        if (showPaths && pts.length >= 2) {
          L.polyline(pts, { pane: panes.paths, color, weight: pathWeight, opacity: 0.95, interactive:false }).addTo(layers.paths);

          for (let i = 1; i < pts.length; i++) {
            const from = pts[i-1], to = pts[i];
            if (from.equals(to)) continue;
            const cssAngle = (Arma3Map.bearing(from, to) - 90);
            const mid = segmentMidpoint(from, to);
            const size = Math.round(arrowSize), half = Math.round(size/2);
            const arrow = L.divIcon({
              className: '',
              html: `<div class="arrow-icon" style="transform: rotate(${cssAngle}deg); font-size:${size}px; width:${size}px; height:${size}px;">‚û§</div>`,
              iconSize:[size,size], iconAnchor:[half,half]
            });
            L.marker(mid, { pane: panes.arrows, icon: arrow, interactive:false }).addTo(layers.arrows);
          }
        }
      });

      // Hits Handler
      if (showHits) {
        const hitsInWindow = damageEvents.filter(d => d.time >= start && d.time <= end && selected.has(d.victim.name));

        hitsInWindow.forEach(evt => {
          const vColor = playerColors[evt.victim.name] || '#ff4d4d';
          const iconSize = Math.round(starSize), half = Math.round(iconSize/2);

          const star = L.divIcon({
            className: '',
            html: `<div class="star-icon" style="color:${vColor}; font-size:${iconSize}px; width:${iconSize}px; height:${iconSize}px;">‚ú¥</div>`,
            iconSize: [iconSize, iconSize],
            iconAnchor: [half, half]
          });

          const marker = L.marker([evt.victim.y, evt.victim.x], { pane: panes.damage, icon: star, bubblingMouseEvents:false })
            .addTo(layers.hits);

          let tip;
          if (evt.kind === 'pvp') {
            tip = `
              <div class="tip-name">${evt.victim.name} <span style="color:#bbb">damaged by</span> ${evt.attacker.name}</div>
              <div class="tip-time">${evt.time}</div>
              <div>Damage Received: <strong>${evt.damage.toFixed(2)}</strong></div>
              <div>Weapon Used: <strong>${evt.weapon}</strong></div>
              <div>Bodypart Hit: <strong>${evt.bodypart}</strong></div>
              <div>Position: <span class="tip-coord">${coordsHTML(evt.victim.x, evt.victim.y, evt.victim.z)}</span></div>
            `;
          } else {
            let byLabel = evt.by;
            if (evt.bodypart && /^block/i.test(evt.bodypart)) byLabel = `${byLabel} (Blocked)`;
            tip = `
              <div class="tip-name">${evt.victim.name} <span style="color:#bbb">damaged by</span> ${byLabel}</div>
              <div class="tip-time">${evt.time}</div>
              <div>Position: <span class="tip-coord">${coordsHTML(evt.victim.x, evt.victim.y, evt.victim.z)}</span></div>
            `;
          }
          marker.bindTooltip(tip, { direction:'top', sticky:true, opacity:1, className:'marker-tip', offset:L.point(0,-8) });

          if (evt.kind === 'pvp') {
            marker.on('click', () => enterDamageFocus({
              type: 'hit',
              victim: evt.victim,
              attacker: evt.attacker
            }));
          }
        });
      }

      // Kills Handler
      if (showKills) {
        const killsInWindow = killEvents.filter(k => k.time >= start && k.time <= end && (selected.has(k.victim.name) || selected.has(k.attacker.name)));

        killsInWindow.forEach(evt => {
          const vColor = playerColors[evt.victim.name] || '#ff4d4d';
          const size = Math.round(skullSize), half = Math.round(size/2);

          const skull = L.divIcon({
            className: '',
            html: `<div class="skull-icon" style="color:${vColor}; font-size:${size}px; width:${size}px; height:${size}px;">‚ò†</div>`,
            iconSize: [size, size],
            iconAnchor: [half, half]
          });

          const m = L.marker([evt.victim.y, evt.victim.x], { pane: panes.kills, icon: skull, bubblingMouseEvents:false })
            .addTo(layers.kills);

          const tip = `
            <div class="tip-name">${evt.victim.name} <span style="color:#bbb">killed by</span> ${evt.attacker.name}</div>
            <div class="tip-time">${evt.time}</div>
            <div>Weapon Used: <strong>${evt.weapon}</strong></div>
            <div>Position: <span class="tip-coord">${coordsHTML(evt.victim.x, evt.victim.y, evt.victim.z)}</span></div>
          `;
          m.bindTooltip(tip, { direction:'top', sticky:true, opacity:1, className:'marker-tip', offset:L.point(0,-8) });

          m.on('click', () => enterDamageFocus({
            type: 'kill',
            victim: evt.victim,
            attacker: evt.attacker
          }));
        });
      }
    }

    function enterDamageFocus(evt) {
      if (inDamageFocus) exitDamageFocus();
      inDamageFocus = true;

      layers.markers.clearLayers();
      layers.paths.clearLayers();
      layers.arrows.clearLayers();
      layers.hits.clearLayers();
      layers.kills.clearLayers();

      const vColor = playerColors[evt.victim.name]   || '#e53935';
      const aColor = playerColors[evt.attacker.name] || '#1e88e5';

      const vIcon = L.divIcon({
        className: '',
        html: `<div class="focus-pin focus-v" title="Victim" style="background:${vColor}">V</div>`,
        iconSize:[22,22], iconAnchor:[11,11]
      });
      const aIcon = L.divIcon({
        className: '',
        html: `<div class="focus-pin focus-a" title="Attacker" style="background:${aColor}">A</div>`,
        iconSize:[22,22], iconAnchor:[11,11]
      });

      const v = L.marker([evt.victim.y, evt.victim.x], { pane: panes.focus, icon: vIcon })
        .bindTooltip(
          `<div><strong>${evt.victim.name}</strong> (Victim)</div><div>Position: ${coordsHTML(evt.victim.x, evt.victim.y, evt.victim.z)}</div>`,
          { direction:'top', sticky:true, opacity:1, className:'marker-tip', offset:L.point(0,-8) }
        ).addTo(layers.focus);

      const a = L.marker([evt.attacker.y, evt.attacker.x], { pane: panes.focus, icon: aIcon })
        .bindTooltip(
          `<div><strong>${evt.attacker.name}</strong> (Attacker)</div><div>Position: ${coordsHTML(evt.attacker.x, evt.attacker.y, evt.attacker.z)}</div>`,
          { direction:'top', sticky:true, opacity:1, className:'marker-tip', offset:L.point(0,-8) }
        ).addTo(layers.focus);

      const b = L.latLngBounds([v.getLatLng(), a.getLatLng()]).pad(0.1);
      map.fitBounds(b, { animate: true });

      const off = () => { map.off('movestart', off); map.off('zoomstart', off); exitDamageFocus(); };
      map.on('movestart', off);
      map.on('zoomstart', off);
    }

    function exitDamageFocus() {
      layers.focus.clearLayers();
      inDamageFocus = false;
      refreshMapLayers();
    }

  function renderConnectionLogs(){
    const target = document.getElementById('logs-conn');
    const selected = new Set(getSelectedPlayers());
    if (!selected.size) {
      target.innerHTML = '<em>No players selected.</em>';
      return;
    }
    if (!connectionLines.length){
      target.innerHTML = '<em>No connection data in this file.</em>';
      return;
    }
    const start = document.getElementById('startTime').value || '00:00:00';
    const end   = document.getElementById('endTime').value   || '23:59:59';
    const exSec = extraWindowSecs();
    const s0 = timeToSec(start) - exSec;
    const e0 = timeToSec(end)   + exSec;
    const byPlayer = new Map();
    connectionLines.forEach(e=>{
      if (!selected.has(e.name)) return;
      const t = timeToSec(e.time);
      if (t < s0 || t > e0) return; 
      if (!byPlayer.has(e.name)) byPlayer.set(e.name, []);
      byPlayer.get(e.name).push(e);
    });
    const chunks = [];
    [...byPlayer.entries()]
      .sort((a,b)=> a[0].localeCompare(b[0]))
      .forEach(([name, list])=>{
        list.sort((a,b)=> timeToSec(a.time)-timeToSec(b.time));
        if (!list.length) return;
        const lines = list.map(e =>
          `${e.time} | ${name} ${e.type==='connect' ? 'is connected' : 'has been disconnected'}`
        );
        chunks.push(name + '\n' + lines.join('\n'));
      });
    target.innerHTML = chunks.length
      ? `<pre class="mono">${chunks.join('\n\n')}</pre>`
      : '<em>No matching connection events for the selected players and timeframe.</em>';
  }

  function renderPositionLogs(){
    const target = document.getElementById('logs-pos');
    const selected = new Set(getSelectedPlayers());
    if (!selected.size) {
      target.innerHTML = '<em>No players selected.</em>';
      return;
    }
    if (!admEntries.length){
      target.innerHTML = '<em>No position data in this file.</em>';
      return;
    }
    const start = document.getElementById('startTime').value || '00:00:00';
    const end   = document.getElementById('endTime').value   || '23:59:59';
    const exSec = extraWindowSecs();
    const s0 = timeToSec(start) - exSec;
    const e0 = timeToSec(end)   + exSec;
    const byPlayer = new Map();
    admEntries.forEach(e=>{
      if (!selected.has(e.name)) return;
      const t = timeToSec(e.time);
      if (t < s0 || t > e0) return;
      if (!byPlayer.has(e.name)) byPlayer.set(e.name, []);
      byPlayer.get(e.name).push(e);
    });  
    const chunks = [];
    [...byPlayer.entries()]
      .sort((a,b)=> a[0].localeCompare(b[0]))
      .forEach(([name, list])=>{
        list.sort((a,b)=> timeToSec(a.time)-timeToSec(b.time));
        if (!list.length) return;
          const lines = list.map(e => {
          const inside = !!(currentRadiusCircle && currentRadiusCenter && currentRadiusMeters && distXY({ x: e.x, y: e.y }, currentRadiusCenter) <= currentRadiusMeters);
          const coordsText = `${e.x.toFixed(1)}, ${e.y.toFixed(1)}, ${e.z.toFixed(1)}`;
          const coordsHTML = inside ? `<span class="hl-pos">${coordsText}</span>` : coordsText;
          const posHTML    = `pos=<${coordsHTML}>`;
          return `${e.time} | ${name} (${posHTML})`;
        });
        chunks.push(name + '\n' + lines.join('\n'));
      });
    target.innerHTML = chunks.length
      ? `<pre class="mono">${chunks.join('\n\n')}</pre>`
      : '<em>No matching position events for the selected players and timeframe.</em>';
  }    

  function renderHitLogs(){
    const outEl = document.getElementById('logs-hit');
    const sel = new Set(getSelectedPlayers());
    if (!sel.size) { outEl.innerHTML = '<em>No players selected.</em>'; return; }
    if (!window._rawLines) { outEl.innerHTML = '<em>No data yet.</em>'; return; }
  
    const start = document.getElementById('startTime').value || '00:00:00';
    const end   = document.getElementById('endTime').value   || '23:59:59';
    const exSec = extraWindowSecs();
    const s0 = timeToSec(start) - exSec;
    const e0 = timeToSec(end)   + exSec;
  
    const byPlayer = new Map(); // victimName -> [{t, line}]
  
    for (const raw of window._rawLines) {
      // match any hit line
      let m = raw.match(HIT_PVP_RE) || raw.match(HIT_PVP_MELEE_RE) || raw.match(HIT_OTHER_RE);
      if (!m) continue;
  
      const tStr = lineTime(raw);
      if (!tStr) continue;
      const t = timeToSec(tStr);
      if (t < s0 || t > e0) continue;
  
      // victim is capture group 2 for all three patterns we use
      const victimName = m[2];
      if (!sel.has(victimName)) continue; // ONLY show damage received by selected players
  
      const cleaned = stripIds(raw);
      if (!byPlayer.has(victimName)) byPlayer.set(victimName, []);
      byPlayer.get(victimName).push({ t, line: cleaned });
    }
  
    const chunks = [];
    [...byPlayer.entries()]
      .sort((a,b)=> a[0].localeCompare(b[0]))
      .forEach(([name, arr])=>{
        arr.sort((a,b)=> a.t - b.t);
        const lines = arr.map(x => x.line);
        if (lines.length) chunks.push(name + '\n' + lines.join('\n'));
      });
  
    outEl.innerHTML = chunks.length
      ? `<pre class="mono">${chunks.join('\n\n')}</pre>`
      : '<em>No matching hit logs in the selected window.</em>';
  }

  function renderKillLogs(){
    const outEl = document.getElementById('logs-kill');
    const sel = new Set(getSelectedPlayers());
    if (!sel.size) { outEl.innerHTML = '<em>No players selected.</em>'; return; }
    if (!window._rawLines) { outEl.innerHTML = '<em>No data yet.</em>'; return; }
  
    const start = document.getElementById('startTime').value || '00:00:00';
    const end   = document.getElementById('endTime').value   || '23:59:59';
    const exSec = extraWindowSecs();
    const s0 = timeToSec(start) - exSec;
    const e0 = timeToSec(end)   + exSec;
  
    const byPlayer = new Map(); // victimName -> [{t, line}]
  
    for (const raw of window._rawLines) {
      const m = raw.match(KILL_PVP_RE);
      if (!m) continue;
  
      const tStr = lineTime(raw);
      if (!tStr) continue;
      const t = timeToSec(tStr);
      if (t < s0 || t > e0) continue;
  
      const victimName = m[2];
      if (!sel.has(victimName)) continue; // only show kills where selected player was victim
  
      const cleaned = stripIds(raw);
      if (!byPlayer.has(victimName)) byPlayer.set(victimName, []);
      byPlayer.get(victimName).push({ t, line: cleaned });
    }
  
    const chunks = [];
    [...byPlayer.entries()]
      .sort((a,b)=> a[0].localeCompare(b[0]))
      .forEach(([name, arr])=>{
        arr.sort((a,b)=> a.t - b.t);
        const lines = arr.map(x => x.line);
        if (lines.length) chunks.push(name + '\n' + lines.join('\n'));
      });
  
    outEl.innerHTML = chunks.length
      ? `<pre class="mono">${chunks.join('\n\n')}</pre>`
      : '<em>No matching kill logs in the selected window.</em>';
  }
    
  function renderChatLogs() {
    const outEl = document.getElementById('logs-chat');
    outEl.innerHTML = '';
    const sel = new Set(getSelectedPlayers());
    if (!sel.size) { outEl.innerHTML = '<em>No players selected.</em>'; return; }
    if (!window._rawLines) { outEl.innerHTML = '<em>No data yet.</em>'; return; }
    const start = document.getElementById('startTime').value || '00:00:00';
    const end   = document.getElementById('endTime').value   || '23:59:59';
    const exSec = extraWindowSecs();
    const s0 = timeToSec(start) - exSec;
    const e0 = timeToSec(end)   + exSec;  
    const grouped = {};
    for (const raw of window._rawLines) {
      const m = raw.match(CHAT_RE);
      if (!m) continue;
      const time = m[1], name = m[2], msg = m[3];
      const t = timeToSec(time);
      if (t < s0 || t > e0) continue;
      if (!sel.has(name)) continue;  
      if (!grouped[name]) grouped[name] = [];
      grouped[name].push(`${time} | ${name}: ${msg}`);
    }   
    const sections = [];
    for (const [name, logs] of Object.entries(grouped)) {
      sections.push(`${name}\n${logs.join('\n')}\n`);
    } 
    outEl.innerHTML = sections.length
      ? `<pre class="mono">${sections.join('\n')}</pre>`
      : '<em>No matching chat logs in the selected window.</em>';
  }
</script>
</body>
</html>
